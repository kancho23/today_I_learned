1. 캐시 기본 동작
- 캐시가 없으면, 데이터가 변경되지 않아도 계속 네트워크를 통해서만 데이터를 다운로드 받아야한다.
- 캐시 덕분에, 캐시 가능 시간동안 네트워크를 사용하지 않아도 된다.
- 캐시 시간이 초과되면, 서버를 통해 데이터를 다시 조회하고 캐시를 갱신한다. 네트워크 다운로드가 다시 발생한다.
' 어차피 데이터가 똑같으면, 좀 아깝지 않나?'

2. 검증헤더와 조건부 요청1
- 캐시 유효시간이 초과해 서버에 다시 요청했을 때
case1. 서버에서 기존 데이터를 변경함
case2. 서버에서 기존 데이터를 변경하지 않음 : 안바뀌었다는 사실만 확인하면, 로컬 데이터를 쓰면된다. 
      Method1.
      - last modified 추가 (검증헤더)
      - if modified since, if unmodified since로 요청보냄 (조건부 요청)
      - 304 Not Modified + HTTP body 없는 상태로 응답

3. 검증헤더와 조건부 요청2
case1. 서버에서 기존 데이터를 변경함
case2. 서버에서 기존 데이터를 변경하지 않음 : 안바뀌었다는 사실만 확인하면, 로컬 데이터를 쓰면된다. 
      Method1의 단점 : 데이터를 수정해서 날짜가 다르지만, 데이터 자체는 바뀌지 않은 경우
      Method2.
      - 캐시용 데이터에 임의의 고유한 버전 이름 달아둠 : ETag(Entity Tag) 검증헤더
      - if match, if none match로 요청보냄 (조건부 요청)
      - 단순하게 ETag만 보내서 같으면 유지, 다르면 다시 받기
      
4. 캐시와 조건부 요청 헤더
- cache control (캐시제어)
      - max age :캐시 유효시간
      - no cache : 데이터는 캐시해도 되지만, 항상 원(origin) 서버에 검증하고 사용
      - no store : 데이터에 민감한 정보가 있으므로 저장하면 안됨
- pragma (캐시제어 하위호환)
- expires (캐시만료일지정 하위호환)

5. 프록시 캐시
* origin 서버가 미국에 있다고 해보자. 너무 오래걸려서 한국 어딘가 '프록시 캐시 서버'를 둔다.
유튜브도 사람들이 많이보는 것만 빠르고, 외국 잘 안보는 영상은 느린이유도 이거 때문이다. 미리 한국 서버가 받아둬서..
한국 프록시 캐시 서버를 'public 캐시', 개인 웹브라우저 캐시를 'private 캐시'라 한다.
- cache control : public (응답이 public 캐시에 저장되어도 됨)
- cache control : private (프록시 캐시 서버에 저장되면 안됨, private 캐시에만 저장)
- cache control : s-maxage (프록시 캐시 서버에만 적용되는 max-age)
- age : 60 (오리진 서버에서 응답후, 프록시 캐시 서버 내에 머문 시간)

6. 캐시 무효화
- cache control : no cache, no store, must revalidate
- pragma (하위호환) : no cache
* 진짜 절대절대 캐시가되면 안되는 부분에 이 두 문장 넣으면 됨
일전에 설명하지 않은 것 중 must revalidate는 '캐시 만료 후 최초 조회시 원 서버에 검증해야함'을 의미

'이게 no cache가 있는데 왜 필요하지?'
원 서버에 일시적으로 네트워크가 단절되어 접근이 불가되면, 오류보다 오래된 데이터라도 보여주자는 세팅때문에 응답이 되어버릴 수 있음
따라서, must revalidate를 통해서 '원 서버에 접근할 수 없는 경우 무조건 항상! 오류가 발생함'
